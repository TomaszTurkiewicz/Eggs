package com.tt.eggs.drawable

import android.content.Context
import android.graphics.*
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.tt.eggs.R
import com.tt.eggs.classes.Functions

class WolfLeftTop (private val context: Context, private val width: Double): Drawable() {
    private val paint = Paint()
    private val unit = width/100

    override fun draw(canvas: Canvas) {

        paint.style = Paint.Style.FILL_AND_STROKE
        paint.color = ContextCompat.getColor(context, R.color.black)
        paint.strokeWidth = (unit/2).toFloat()

        var a = Point((width*0.5).toInt(), (width*0.1).toInt())
        var b = Point((width*0.48).toInt(), (width*0.09).toInt())
        var radiusAB = Functions.curvedPath(a,b,unit*5,true)
        var c = Point((width*0.52).toInt(), (width*0.05).toInt())
        var d = Point((width*0.68).toInt(), (width*0.13).toInt())
        var e = Point((width*0.68).toInt(), (width*0.17).toInt())
        var f = Point((width*0.73).toInt(), (width*0.2).toInt())
        var g = Point((width*0.81).toInt(), (width*0.26).toInt())
        var radiusFG = Functions.curvedPath(f,g,unit*12,true)
        var h = Point((width*0.77).toInt(), (width*0.23).toInt())
        var radiusGH = Functions.curvedPath(g,h,unit,false)
        var i = Point((width*0.79).toInt(), (width*0.27).toInt())
        var j = Point((width*0.79).toInt(), (width*0.37).toInt())
        var radiusIJ = Functions.curvedPath(i,j,unit*3,true)
        var k = Point((width*0.765).toInt(), (width*0.29).toInt())
        var radiusJK = Functions.curvedPath(j,k,unit*2,false)
        var l = Point((width*0.75).toInt(), (width*0.38).toInt())
        var radiusKL = Functions.curvedPath(k,l,unit*1,true)
        var m = Point((width*0.67).toInt(), (width*0.38).toInt())
        var radiusLM = Functions.curvedPath(l,m,unit*2,false)
        var n = Point((width*0.67).toInt(), (width*0.31).toInt())
        var radiusMN = Functions.curvedPath(m,n,unit*3,false)
        var o = Point((width*0.66).toInt(), (width*0.275).toInt())
        var radiusNO = Functions.curvedPath(n,o,unit*2,false)
        var p = Point((width*0.66).toInt(), (width*0.2).toInt())
        var radiusOP = Functions.curvedPath(o,p,unit*3,false)
        var r = Point((width*0.55).toInt(), (width*0.14).toInt())
        var s = Point((width*0.51).toInt(), (width*0.16).toInt())
        var radiusRS = Functions.curvedPath(r,s,unit*2,false)
        var t = Point((width*0.495).toInt(), (width*0.16).toInt())
        var radiusST = Functions.curvedPath(s,t,unit*2,true)
        var u = Point((width*0.54).toInt(), (width*0.11).toInt())
        var radiusTU = Functions.curvedPath(t,u,unit*2,true)
        var v = Point((width*0.54).toInt(), (width*0.09).toInt())
        var radiusUV = Functions.curvedPath(u,v,unit*2,false)
        var radiusVA = Functions.curvedPath(v,a,unit,false)



        val path = Path()
        path.moveTo(a.x.toFloat(), a.y.toFloat())
        path.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        path.lineTo(c.x.toFloat(), c.y.toFloat())
        path.lineTo(d.x.toFloat(), d.y.toFloat())
        path.lineTo(e.x.toFloat(), e.y.toFloat())
        path.lineTo(f.x.toFloat(), f.y.toFloat())
        path.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        path.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        path.lineTo(i.x.toFloat(), i.y.toFloat())
        path.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        path.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        path.cubicTo(k.x.toFloat(), k.y.toFloat(),radiusKL.x,radiusKL.y, l.x.toFloat(), l.y.toFloat())
        path.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        path.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        path.cubicTo(n.x.toFloat(), n.y.toFloat(),radiusNO.x,radiusNO.y, o.x.toFloat(), o.y.toFloat())
        path.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())
        path.lineTo(r.x.toFloat(), r.y.toFloat())
        path.cubicTo(r.x.toFloat(), r.y.toFloat(),radiusRS.x,radiusRS.y, s.x.toFloat(), s.y.toFloat())
        path.cubicTo(s.x.toFloat(), s.y.toFloat(),radiusST.x,radiusST.y, t.x.toFloat(), t.y.toFloat())
        path.cubicTo(t.x.toFloat(), t.y.toFloat(),radiusTU.x,radiusTU.y, u.x.toFloat(), u.y.toFloat())
        path.cubicTo(u.x.toFloat(), u.y.toFloat(),radiusUV.x,radiusUV.y, v.x.toFloat(), v.y.toFloat())
        path.cubicTo(v.x.toFloat(), v.y.toFloat(),radiusVA.x,radiusVA.y, a.x.toFloat(), a.y.toFloat())
        path.close()

        canvas.drawPath(path,paint)

        paint.style = Paint.Style.FILL_AND_STROKE

        val path1 = Path()

        a = Point((width*0.73).toInt(), (width*0.375).toInt())
        b = Point((width*0.73).toInt(), (width*0.42).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,false)
        c = Point((width*0.73).toInt(), (width*0.44).toInt())
        var radiusBC = Functions.curvedPath(b,c,unit,true)
        d = Point((width*0.65).toInt(), (width*0.55).toInt())
        e = Point((width*0.63).toInt(), (width*0.63).toInt())
        f = Point((width*0.6).toInt(), (width*0.66).toInt())
        g = Point((width*0.58).toInt(), (width*0.67).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*2,false)
        h = Point((width*0.49).toInt(), (width*0.66).toInt())
        radiusGH = Functions.curvedPath(g,h,unit,false)
        i = Point((width*0.47).toInt(), (width*0.61).toInt())
        var radiusHI = Functions.curvedPath(h,i,unit*3,true)
        j = Point((width*0.51).toInt(), (width*0.55).toInt())
        k = Point((width*0.54).toInt(), (width*0.49).toInt())
        radiusJK = Functions.curvedPath(j,k,unit,true)
        l = Point((width*0.56).toInt(), (width*0.44).toInt())
        radiusKL = Functions.curvedPath(k,l,unit,false)
        m = Point((width*0.6).toInt(), (width*0.41).toInt())
        radiusLM = Functions.curvedPath(l,m,unit*2,true)
        n = Point((width*0.605).toInt(), (width*0.45).toInt())
        radiusMN = Functions.curvedPath(m,n,unit*2,true)
        o = Point((width*0.58).toInt(), (width*0.5).toInt())
        p = Point((width*0.565).toInt(), (width*0.535).toInt())
        radiusOP = Functions.curvedPath(o,p,unit*2,false)
        var q = Point((width*0.63).toInt(), (width*0.5).toInt())
        var radiusPQ = Functions.curvedPath(p,q,unit*3,false)
        r = Point((width*0.68).toInt(), (width*0.41).toInt())
        s = Point((width*0.69).toInt(), (width*0.39).toInt())
        radiusRS = Functions.curvedPath(r,s,unit,true)
        t = Point((width*0.69).toInt(), (width*0.37).toInt())
        radiusST = Functions.curvedPath(s,t,unit,false)

        path1.moveTo(a.x.toFloat(), a.y.toFloat())
        path1.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        path1.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        path1.lineTo(d.x.toFloat(), d.y.toFloat())
        path1.lineTo(e.x.toFloat(), e.y.toFloat())
        path1.lineTo(f.x.toFloat(), f.y.toFloat())
        path1.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        path1.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        path1.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        path1.lineTo(j.x.toFloat(), j.y.toFloat())
        path1.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        path1.cubicTo(k.x.toFloat(), k.y.toFloat(),radiusKL.x,radiusKL.y, l.x.toFloat(), l.y.toFloat())
        path1.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        path1.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        path1.lineTo(o.x.toFloat(), o.y.toFloat())
        path1.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())
        path1.cubicTo(p.x.toFloat(), p.y.toFloat(),radiusPQ.x,radiusPQ.y, q.x.toFloat(), q.y.toFloat())
        path1.lineTo(r.x.toFloat(), r.y.toFloat())
        path1.cubicTo(r.x.toFloat(), r.y.toFloat(),radiusRS.x,radiusRS.y, s.x.toFloat(), s.y.toFloat())
        path1.cubicTo(s.x.toFloat(), s.y.toFloat(),radiusST.x,radiusST.y, t.x.toFloat(), t.y.toFloat())
        path1.close()

        canvas.drawPath(path1,paint)


        paint.style = Paint.Style.STROKE
        paint.strokeWidth = (unit*1.5).toFloat()
        val pathLegs = Path()

        a= Point((width*0.62).toInt(), (width*0.62).toInt())
        b= Point((width*0.78).toInt(), (width*0.72).toInt())
        c = Point((width*0.79).toInt(), (width*0.76).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*2,true)
        d = Point((width*0.75).toInt(), (width*0.855).toInt())
        e = Point((width*0.68).toInt(), (width*0.9).toInt())
        f = Point((width*0.84).toInt(), (width*0.84).toInt())
        var radiusEF = Functions.curvedPath(e,f,unit*4,true)
        g = Point((width*0.85).toInt(), (width*0.87).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*4,true)
        h = Point((width*0.68).toInt(), (width*0.94).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*4,true)
        var radiusHE = Functions.curvedPath(h,e,unit*3,true)
        i = Point((width*0.73).toInt(), (width*0.78).toInt())
        j = Point((width*0.71).toInt(), (width*0.75).toInt())
        radiusIJ = Functions.curvedPath(i,j,unit*3,false)
        k = Point((width*0.54).toInt(), (width*0.73).toInt())
        l = Point((width*0.435).toInt(), (width*0.77).toInt())
        m = Point((width*0.55).toInt(), (width*0.86).toInt())
        n = Point((width*0.53).toInt(), (width*0.95).toInt())
        radiusMN = Functions.curvedPath(m,n,unit*9,true)
        o = Point((width*0.36).toInt(), (width*0.93).toInt())
        radiusNO = Functions.curvedPath(n,o,unit*4,true)
        p = Point((width*0.34).toInt(), (width*0.87).toInt())
        radiusOP = Functions.curvedPath(o,p,unit*4,true)
        q = Point((width*0.48).toInt(), (width*0.885).toInt())
        radiusPQ = Functions.curvedPath(p,q,unit*3,true)
        r = Point((width*0.49).toInt(), (width*0.86).toInt())
        var radiusQR = Functions.curvedPath(q,r,unit*6,false)
        s = Point((width*0.36).toInt(), (width*0.785).toInt())
        t = Point((width*0.35).toInt(), (width*0.74).toInt())
        radiusST = Functions.curvedPath(s,t,unit*4,true)
        u = Point((width*0.49).toInt(), (width*0.64).toInt())
        radiusTU = Functions.curvedPath(t,u,unit,true)

        pathLegs.moveTo(a.x.toFloat(), a.y.toFloat())
        pathLegs.lineTo(b.x.toFloat(), b.y.toFloat())
        pathLegs.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathLegs.lineTo(d.x.toFloat(), d.y.toFloat())
        pathLegs.moveTo(e.x.toFloat(), e.y.toFloat())
        pathLegs.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathLegs.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        pathLegs.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        pathLegs.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHE.x,radiusHE.y, e.x.toFloat(), e.y.toFloat())
        pathLegs.lineTo(i.x.toFloat(), i.y.toFloat())
        pathLegs.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        pathLegs.lineTo(k.x.toFloat(), k.y.toFloat())
        pathLegs.lineTo(l.x.toFloat(), l.y.toFloat())
        pathLegs.lineTo(m.x.toFloat(), m.y.toFloat())
        pathLegs.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        pathLegs.cubicTo(n.x.toFloat(), n.y.toFloat(),radiusNO.x,radiusNO.y, o.x.toFloat(), o.y.toFloat())
        pathLegs.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())
        pathLegs.cubicTo(p.x.toFloat(), p.y.toFloat(),radiusPQ.x,radiusPQ.y, q.x.toFloat(), q.y.toFloat())
        pathLegs.cubicTo(q.x.toFloat(), q.y.toFloat(),radiusQR.x,radiusQR.y, r.x.toFloat(), r.y.toFloat())
        pathLegs.lineTo(s.x.toFloat(), s.y.toFloat())
        pathLegs.cubicTo(s.x.toFloat(), s.y.toFloat(),radiusST.x,radiusST.y, t.x.toFloat(), t.y.toFloat())
        pathLegs.cubicTo(t.x.toFloat(), t.y.toFloat(),radiusTU.x,radiusTU.y, u.x.toFloat(), u.y.toFloat())

        canvas.drawPath(pathLegs,paint)


        val pathPants = Path()

        a = Point((width*0.45).toInt(), (width*0.76).toInt())
        b = Point((width*0.37).toInt(), (width*0.71).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,false)
        c = Point((width*0.5).toInt(), (width*0.6).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*2,false)
        d = Point((width*0.38).toInt(), (width*0.87).toInt())
        e = Point((width*0.41).toInt(), (width*0.92).toInt())
        var radiusDE = Functions.curvedPath(d,e,unit*4,false)
        f = Point((width*0.58).toInt(), (width*0.9).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*3,false)
        g = Point((width*0.68).toInt(), (width*0.94).toInt())
        h = Point((width*0.855).toInt(), (width*0.86).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*3,true)
        i = Point((width*0.68).toInt(), (width*0.745).toInt())
        j = Point((width*0.73).toInt(), (width*0.67).toInt())
        radiusIJ = Functions.curvedPath(i,j,unit,true)
        k = Point((width*0.6).toInt(), (width*0.6).toInt())
        radiusJK = Functions.curvedPath(j,k,unit,true)
        l = Point((width*0.65).toInt(), (width*0.63).toInt())
        m = Point((width*0.73).toInt(), (width*0.58).toInt())
        radiusLM = Functions.curvedPath(l,m,unit,true)
        n = Point((width*0.76).toInt(), (width*0.6).toInt())
        radiusMN = Functions.curvedPath(m,n,unit*3,true)
        o = Point((width*0.69).toInt(), (width*0.65).toInt())
        radiusNO = Functions.curvedPath(n,o,unit*2,true)

        pathPants.moveTo(a.x.toFloat(), a.y.toFloat())
        pathPants.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathPants.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathPants.moveTo(d.x.toFloat(), d.y.toFloat())
        pathPants.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        pathPants.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathPants.moveTo(g.x.toFloat(), g.y.toFloat())
        pathPants.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        pathPants.moveTo(i.x.toFloat(), i.y.toFloat())
        pathPants.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        pathPants.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        pathPants.moveTo(l.x.toFloat(), l.y.toFloat())
        pathPants.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        pathPants.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        pathPants.cubicTo(n.x.toFloat(), n.y.toFloat(),radiusNO.x,radiusNO.y, o.x.toFloat(), o.y.toFloat())

        canvas.drawPath(pathPants,paint)


        paint.strokeWidth = (unit*1.5).toFloat()
        a = Point((width*0.68).toInt(), (width*0.17).toInt())
        b = Point((width*0.77).toInt(), (width*0.05).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*6,true)
        c = Point((width*0.73).toInt(), (width*0.2).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*7,true)
        d = Point((width*0.70).toInt(), (width*0.18).toInt())
        e = Point((width*0.74).toInt(), (width*0.13).toInt())
        radiusDE = Functions.curvedPath(d,e,unit*2,true)
        f = Point((width*0.71).toInt(), (width*0.19).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*2,true)
        g = Point((width*0.56).toInt(), (width*0.08).toInt())
        h = Point((width*0.64).toInt(), (width*0.08).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*5,true)
        i = Point((width*0.7).toInt(), (width*0.09).toInt())
        j = Point((width*0.68).toInt(), (width*0.12).toInt())
        k = Point((width*0.62).toInt(), (width*0.105).toInt())
        l = Point((width*0.64).toInt(), (width*0.08).toInt())
        m = Point((width*0.63).toInt(), (width*0.08).toInt())
        n = Point((width*0.61).toInt(), (width*0.105).toInt())
        radiusHI = Functions.curvedPath(h,i,unit*3,true)
        o = Point((width*0.67).toInt(), (width*0.07).toInt())
        p = Point((width*0.7).toInt(), (width*0.08).toInt())
        radiusOP = Functions.curvedPath(o,p,unit*8,true)



        val pathEar = Path()
        pathEar.moveTo(a.x.toFloat(), a.y.toFloat())
        pathEar.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathEar.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathEar.moveTo(d.x.toFloat(), d.y.toFloat())
        pathEar.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        pathEar.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathEar.moveTo(g.x.toFloat(), g.y.toFloat())
        pathEar.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        pathEar.lineTo(i.x.toFloat(), i.y.toFloat())
        pathEar.lineTo(j.x.toFloat(), j.y.toFloat())
        pathEar.lineTo(k.x.toFloat(), k.y.toFloat())
        pathEar.lineTo(l.x.toFloat(), l.y.toFloat())
        pathEar.lineTo(m.x.toFloat(), m.y.toFloat())
        pathEar.lineTo(n.x.toFloat(), n.y.toFloat())
        pathEar.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        pathEar.moveTo(o.x.toFloat(), o.y.toFloat())
        pathEar.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())

        canvas.drawPath(pathEar,paint)

        paint.style = Paint.Style.FILL_AND_STROKE
        paint.strokeWidth = (unit*0.5).toFloat()
        a = Point((width*0.55).toInt(), (width*0.14).toInt())
        b = Point((width*0.525).toInt(), (width*0.21).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,false)
        c = Point((width*0.54).toInt(), (width*0.21).toInt())
        d = Point((width*0.57).toInt(), (width*0.18).toInt())
        var radiusCD = Functions.curvedPath(c,d,unit*4,true)
        e = Point((width*0.61).toInt(), (width*0.2).toInt())
        radiusDE = Functions.curvedPath(d,e,unit*5,true)
        f = Point((width*0.63).toInt(), (width*0.21).toInt())
        g = Point((width*0.68).toInt(), (width*0.17).toInt())

        val path2 = Path()
        path2.moveTo(a.x.toFloat(), a.y.toFloat())
        path2.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        path2.lineTo(c.x.toFloat(), c.y.toFloat())
        path2.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCD.x,radiusCD.y, d.x.toFloat(), d.y.toFloat())
        path2.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        path2.lineTo(f.x.toFloat(), f.y.toFloat())
        path2.lineTo(g.x.toFloat(), g.y.toFloat())
        path2.close()

        canvas.drawPath(path2,paint)


        paint.style = Paint.Style.STROKE
        paint.strokeWidth = (unit*1.5).toFloat()

        a = Point((width*0.58).toInt(), (width*0.22).toInt())
        b = Point((width*0.63).toInt(), (width*0.21).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*4,true)
        c = Point((width*0.585).toInt(), (width*0.24).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*10,true)
        d = Point((width*0.525).toInt(), (width*0.23).toInt())
        radiusCD = Functions.curvedPath(c,d,unit*6,false)
        e = Point((width*0.565).toInt(), (width*0.28).toInt())
        var radiusEA = Functions.curvedPath(e,a,unit*3,false)
        f = Point((width*0.53).toInt(), (width*0.28).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*4,false)
        g = Point((width*0.41).toInt(), (width*0.26).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*8,false)
        h = Point((width*0.42).toInt(), (width*0.31).toInt())
        i = Point((width*0.43).toInt(), (width*0.37).toInt())
        radiusHI = Functions.curvedPath(h,i,unit,false)
        j = Point((width*0.47).toInt(), (width*0.39).toInt())
        radiusIJ = Functions.curvedPath(i,j,unit,true)
        k = Point((width*0.51).toInt(), (width*0.4).toInt())
        radiusJK = Functions.curvedPath(j,k,unit*2,false)
        l = Point((width*0.58).toInt(), (width*0.36).toInt())
        radiusKL = Functions.curvedPath(k,l,unit,false)
        m = Point((width*0.64).toInt(), (width*0.35).toInt())
        radiusLM = Functions.curvedPath(l,m,unit*2,false)
        n = Point((width*0.6).toInt(), (width*0.44).toInt())
        radiusMN = Functions.curvedPath(m,n,unit*2,false)

        val pathFace = Path()
        pathFace.moveTo(a.x.toFloat(), a.y.toFloat())
        pathFace.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathFace.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathFace.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCD.x,radiusCD.y, d.x.toFloat(), d.y.toFloat())
        pathFace.lineTo(e.x.toFloat(), e.y.toFloat())
        pathFace.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEA.x,radiusEA.y, a.x.toFloat(), a.y.toFloat())
        pathFace.moveTo(e.x.toFloat(), e.y.toFloat())
        pathFace.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathFace.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        pathFace.lineTo(h.x.toFloat(), h.y.toFloat())
        pathFace.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        pathFace.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        pathFace.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        pathFace.cubicTo(k.x.toFloat(), k.y.toFloat(),radiusKL.x,radiusKL.y, l.x.toFloat(), l.y.toFloat())
        pathFace.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        pathFace.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())

        canvas.drawPath(pathFace,paint)


        paint.style = Paint.Style.FILL_AND_STROKE
        paint.strokeWidth = (unit/2).toFloat()

        a = Point((width*0.42).toInt(), (width*0.31).toInt())
        b = Point((width*0.47).toInt(), (width*0.31).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,true)
        c = Point((width*0.47).toInt(), (width*0.35).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*3,false)
        var radiusCB = Functions.curvedPath(c,b,unit*3,false)
        d = Point((width*0.59).toInt(), (width*0.3).toInt())
        var radiusBD = Functions.curvedPath(b,d,unit*2,false)
        e = Point((width*0.61).toInt(), (width*0.32).toInt())
        radiusDE = Functions.curvedPath(d,e,unit*2,true)
        f = Point((width*0.58).toInt(), (width*0.34).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*2,true)
        g = Point((width*0.48).toInt(), (width*0.37).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*2,false)
        h = Point((width*0.43).toInt(), (width*0.36).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*3,false)
        var radiusHA = Functions.curvedPath(h,a,unit*4,false)

        val path3 = Path()
        path3.moveTo(a.x.toFloat(), a.y.toFloat())
        path3.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        path3.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        path3.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCB.x,radiusCB.y, b.x.toFloat(), b.y.toFloat())
        path3.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBD.x,radiusBD.y, d.x.toFloat(), d.y.toFloat())
        path3.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        path3.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        path3.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        path3.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        path3.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHA.x,radiusHA.y, a.x.toFloat(), a.y.toFloat())
        path3.close()

        canvas.drawPath(path3,paint)


        a = Point((width*0.43).toInt(), (width*0.18).toInt())
        b = Point((width*0.445).toInt(), (width*0.27).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*4,true)
        c = Point((width*0.41).toInt(), (width*0.24).toInt())
        var radiusCA = Functions.curvedPath(c,a,unit*4,true)

        val pathNose = Path()
        pathNose.moveTo(a.x.toFloat(), a.y.toFloat())
        pathNose.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathNose.lineTo(c.x.toFloat(), c.y.toFloat())
        pathNose.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCA.x,radiusCA.y, a.x.toFloat(), a.y.toFloat())
        path3.close()

        canvas.drawPath(pathNose,paint)

        paint.style = Paint.Style.FILL_AND_STROKE
//
        paint.strokeWidth = (unit/2).toFloat()

        a = Point((width*0.53).toInt(), (width*0.24).toInt())
        b = Point((width*0.56).toInt(), (width*0.27).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*4,true)


        val pathEye = Path()
        pathEye.moveTo(a.x.toFloat(), a.y.toFloat())
        pathEye.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathEye.close()

        canvas.drawPath(pathEye,paint)

        a = Point((width*0.59).toInt(), (width*0.23).toInt())
        b = Point((width*0.62).toInt(), (width*0.26).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*4,true)


        val pathEye1 = Path()
        pathEye1.moveTo(a.x.toFloat(), a.y.toFloat())
        pathEye1.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathEye1.close()

        canvas.drawPath(pathEye1,paint)

        paint.style = Paint.Style.STROKE

        paint.strokeWidth = (unit*1.5).toFloat()

        a = Point((width*0.2).toInt(), (width*0.07).toInt())
        b = Point((width*0.15).toInt(), (width*0.1).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,false)
        c = Point((width*0.17).toInt(), (width*0.13).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*2,false)
        d = Point((width*0.2).toInt(), (width*0.115).toInt())
        radiusCD = Functions.curvedPath(c,d,unit,true)
        var radiusDA = Functions.curvedPath(d,a,unit*2,false)
        e = Point((width*0.19).toInt(), (width*0.17).toInt())
        var radiusCE = Functions.curvedPath(c,e,unit,false)
        f = Point((width*0.24).toInt(), (width*0.15).toInt())
        radiusEF = Functions.curvedPath(e,f,unit,true)
        g = Point((width*0.24).toInt(), (width*0.125).toInt())
        radiusFG = Functions.curvedPath(f,g,unit/2,true)
        var radiusGD = Functions.curvedPath(g,d,unit,false)
        h = Point((width*0.215).toInt(), (width*0.2).toInt())
        var radiusEH = Functions.curvedPath(e,h,unit,false)
        i = Point((width*0.25).toInt(), (width*0.18).toInt())
        radiusHI = Functions.curvedPath(h,i,unit,true)
        var radiusIF = Functions.curvedPath(i,f,unit/2,true)
        j = Point((width*0.25).toInt(), (width*0.07).toInt())
        var radiusDJ = Functions.curvedPath(d,j,unit*2,true)
        k = Point((width*0.3).toInt(), (width*0.09).toInt())
        radiusJK = Functions.curvedPath(j,k,unit*2,true)
        l = Point((width*0.365).toInt(), (width*0.27).toInt())
        m = Point((width*0.345).toInt(), (width*0.285).toInt())
        radiusLM = Functions.curvedPath(l,m,unit*7,true)
        n = Point((width*0.3).toInt(), (width*0.21).toInt())
        radiusMN = Functions.curvedPath(m,n,unit,true)
        o = Point((width*0.28).toInt(), (width*0.19).toInt())
        radiusNO = Functions.curvedPath(n,o,unit,false)
        p = Point((width*0.26).toInt(), (width*0.14).toInt())
        radiusOP = Functions.curvedPath(o,p,unit,true)
        var radiusPD = Functions.curvedPath(p,d,unit*5,false)



        val pathHandUp = Path()
        pathHandUp.moveTo(a.x.toFloat(), a.y.toFloat())
        pathHandUp.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathHandUp.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathHandUp.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCD.x,radiusCD.y, d.x.toFloat(), d.y.toFloat())
        pathHandUp.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDA.x,radiusDA.y, a.x.toFloat(), a.y.toFloat())
        pathHandUp.moveTo(c.x.toFloat(), c.y.toFloat())
        pathHandUp.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCE.x,radiusCE.y, e.x.toFloat(), e.y.toFloat())
        pathHandUp.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathHandUp.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        pathHandUp.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGD.x,radiusGD.y, d.x.toFloat(), d.y.toFloat())
        pathHandUp.moveTo(e.x.toFloat(), e.y.toFloat())
        pathHandUp.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEH.x,radiusEH.y, h.x.toFloat(), h.y.toFloat())
        pathHandUp.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        pathHandUp.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIF.x,radiusIF.y, f.x.toFloat(), f.y.toFloat())
        pathHandUp.moveTo(d.x.toFloat(), d.y.toFloat())
        pathHandUp.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDJ.x,radiusDJ.y, j.x.toFloat(), j.y.toFloat())
        pathHandUp.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        pathHandUp.lineTo(l.x.toFloat(), l.y.toFloat())
        pathHandUp.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        pathHandUp.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        pathHandUp.cubicTo(n.x.toFloat(), n.y.toFloat(),radiusNO.x,radiusNO.y, o.x.toFloat(), o.y.toFloat())
        pathHandUp.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())
        pathHandUp.cubicTo(p.x.toFloat(), p.y.toFloat(),radiusPD.x,radiusPD.y, d.x.toFloat(), d.y.toFloat())


        canvas.drawPath(pathHandUp,paint)


        a = Point((width*0.16).toInt(), (width*0.275).toInt())
        b = Point((width*0.235).toInt(), (width*0.26).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*8,false)
        c = Point((width*0.24).toInt(), (width*0.22).toInt())
        radiusBC = Functions.curvedPath(b,c,unit,true)
        d = Point((width*0.25).toInt(), (width*0.22).toInt())
        radiusCD = Functions.curvedPath(c,d,unit,true)
        e = Point((width*0.27).toInt(), (width*0.28).toInt())
        radiusDE = Functions.curvedPath(d,e,unit,true)
        f = Point((width*0.3).toInt(), (width*0.33).toInt())
        radiusEF = Functions.curvedPath(e,f,unit/2,false)
        g = Point((width*0.31).toInt(), (width*0.34).toInt())
        radiusFG = Functions.curvedPath(f,g,unit/2,false)
        h = Point((width*0.42).toInt(), (width*0.41).toInt())
        i = Point((width*0.41).toInt(), (width*0.43).toInt())
        radiusHI = Functions.curvedPath(h,i,unit*11,true)
        j = Point((width*0.34).toInt(), (width*0.4).toInt())
        k = Point((width*0.2).toInt(), (width*0.39).toInt())
        radiusJK = Functions.curvedPath(j,k,unit*2,false)
        l = Point((width*0.14).toInt(), (width*0.39).toInt())
        radiusKL = Functions.curvedPath(k,l,unit,true)
        m = Point((width*0.155).toInt(), (width*0.375).toInt())
        radiusLM = Functions.curvedPath(l,m,unit*4,true)
        n = Point((width*0.12).toInt(), (width*0.34).toInt())
        radiusMN = Functions.curvedPath(m,n,unit,true)
        o = Point((width*0.135).toInt(), (width*0.325).toInt())
        radiusNO = Functions.curvedPath(n,o,unit*5,true)
        p = Point((width*0.16).toInt(), (width*0.34).toInt())
        radiusOP = Functions.curvedPath(o,p,1.0,true)
        q = Point((width*0.165).toInt(), (width*0.335).toInt())
        radiusPQ = Functions.curvedPath(p,q,unit*3,false)
        r = Point((width*0.135).toInt(), (width*0.305).toInt())
        radiusQR = Functions.curvedPath(q,r,1.0,false)
        var radiusRA = Functions.curvedPath(r,a,unit*9,true)


        val pathHandDown = Path()
        pathHandDown.moveTo(a.x.toFloat(), a.y.toFloat())
        pathHandDown.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathHandDown.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathHandDown.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCD.x,radiusCD.y, d.x.toFloat(), d.y.toFloat())
        pathHandDown.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        pathHandDown.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathHandDown.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        pathHandDown.lineTo(h.x.toFloat(), h.y.toFloat())
        pathHandDown.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        pathHandDown.lineTo(j.x.toFloat(), j.y.toFloat())
        pathHandDown.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        pathHandDown.cubicTo(k.x.toFloat(), k.y.toFloat(),radiusKL.x,radiusKL.y, l.x.toFloat(), l.y.toFloat())
        pathHandDown.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        pathHandDown.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        pathHandDown.cubicTo(n.x.toFloat(), n.y.toFloat(),radiusNO.x,radiusNO.y, o.x.toFloat(), o.y.toFloat())
        pathHandDown.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())
        pathHandDown.cubicTo(p.x.toFloat(), p.y.toFloat(),radiusPQ.x,radiusPQ.y, q.x.toFloat(), q.y.toFloat())
        pathHandDown.cubicTo(q.x.toFloat(), q.y.toFloat(),radiusQR.x,radiusQR.y, r.x.toFloat(), r.y.toFloat())
        pathHandDown.cubicTo(r.x.toFloat(), r.y.toFloat(),radiusRA.x,radiusRA.y, a.x.toFloat(), a.y.toFloat())
        pathHandDown.close()

        canvas.drawPath(pathHandDown,paint)

        paint.style = Paint.Style.FILL_AND_STROKE
        paint.strokeWidth = (unit/2).toFloat()

        a = Point((width*0.09).toInt(), (width*0.21).toInt())
        b = Point((width*0.09).toInt(), (width*0.04).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*3,true)
        c = Point((width*0.2).toInt(), (width*0.05).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*5,true)
        d = Point((width*0.22).toInt(), (width*0.08).toInt())
        radiusCD = Functions.curvedPath(c,d,0.0,true)
        e = Point((width*0.21).toInt(), (width*0.09).toInt())
        f = Point((width*0.18).toInt(), (width*0.07).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*2,false)
        g = Point((width*0.125).toInt(), (width*0.055).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*2,false)
        h = Point((width*0.11).toInt(), (width*0.13).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*2,false)
        i = Point((width*0.125).toInt(), (width*0.2).toInt())
        radiusHI = Functions.curvedPath(h,i,unit/2,false)
        j = Point((width*0.14).toInt(), (width*0.21).toInt())
        radiusIJ = Functions.curvedPath(i,j,unit,false)
        k = Point((width*0.2).toInt(), (width*0.19).toInt())
        radiusJK = Functions.curvedPath(j,k,unit,true)
        l = Point((width*0.21).toInt(), (width*0.2).toInt())
        radiusKL = Functions.curvedPath(k,l,unit/2,false)
        m = Point((width*0.25).toInt(), (width*0.18).toInt())
        radiusLM = Functions.curvedPath(l,m,unit,true)
        n = Point((width*0.245).toInt(), (width*0.115).toInt())
        radiusMN = Functions.curvedPath(m,n,unit,true)
        o = Point((width*0.28).toInt(), (width*0.19).toInt())
        p = Point((width*0.34).toInt(), (width*0.28).toInt())
        q = Point((width*0.3).toInt(), (width*0.33).toInt())
        radiusPQ = Functions.curvedPath(p,q,unit,true)
        r = Point((width*0.27).toInt(), (width*0.28).toInt())
        radiusQR = Functions.curvedPath(q,r,unit,true)
        s = Point((width*0.25).toInt(), (width*0.22).toInt())
        radiusRS = Functions.curvedPath(r,s,unit,false)
        t = Point((width*0.24).toInt(), (width*0.22).toInt())
        radiusST = Functions.curvedPath(s,t,unit,false)
        u = Point((width*0.235).toInt(), (width*0.26).toInt())
        radiusTU = Functions.curvedPath(t,u,unit,false)
        v = Point((width*0.16).toInt(), (width*0.275).toInt())
        radiusUV = Functions.curvedPath(u,v,unit*8,true)
        var w = Point((width*0.135).toInt(), (width*0.305).toInt())
        var radiusVW = Functions.curvedPath(v,w,unit*9,false)
        var x = Point((width*0.165).toInt(), (width*0.335).toInt())
        var radiusWX = Functions.curvedPath(w,x,0.0,false)
        var y = Point((width*0.135).toInt(), (width*0.325).toInt())
        var radiusXY = Functions.curvedPath(x,y,0.0,true)
        var z = Point((width*0.12).toInt(), (width*0.34).toInt())
        var radiusYZ = Functions.curvedPath(y,z,unit*5,false)
        var a1 = Point((width*0.145).toInt(), (width*0.4).toInt())
        var b1 = Point((width*0.05).toInt(), (width*0.33).toInt())
        var radiusAB1 = Functions.curvedPath(a1,b1,unit*2,true)
        var c1 = Point((width*0.03).toInt(), (width*0.27).toInt())
        var radiusBC1 = Functions.curvedPath(b1,c1,unit*2,true)
        var d1 = Point((width*0.05).toInt(), (width*0.245).toInt())
        var radiusCD1 = Functions.curvedPath(c1,d1,unit,true)
        var e1 = Point((width*0.09).toInt(), (width*0.23).toInt())
        var radiusDE1 = Functions.curvedPath(d1,e1,0.0,false)
        var radiusEA1 = Functions.curvedPath(e1,a,unit,false)


        val pathBasket = Path()
        pathBasket.moveTo(a.x.toFloat(), a.y.toFloat())
        pathBasket.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathBasket.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathBasket.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCD.x,radiusCD.y, d.x.toFloat(), d.y.toFloat())
        pathBasket.lineTo(e.x.toFloat(), e.y.toFloat())
        pathBasket.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathBasket.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        pathBasket.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        pathBasket.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        pathBasket.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        pathBasket.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        pathBasket.cubicTo(k.x.toFloat(), k.y.toFloat(),radiusKL.x,radiusKL.y, l.x.toFloat(), l.y.toFloat())
        pathBasket.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        pathBasket.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        pathBasket.lineTo(o.x.toFloat(), o.y.toFloat())
        pathBasket.lineTo(p.x.toFloat(), p.y.toFloat())
        pathBasket.cubicTo(p.x.toFloat(), p.y.toFloat(),radiusPQ.x,radiusPQ.y, q.x.toFloat(), q.y.toFloat())
        pathBasket.cubicTo(q.x.toFloat(), q.y.toFloat(),radiusQR.x,radiusQR.y, r.x.toFloat(), r.y.toFloat())
        pathBasket.cubicTo(r.x.toFloat(), r.y.toFloat(),radiusRS.x,radiusRS.y, s.x.toFloat(), s.y.toFloat())
        pathBasket.cubicTo(s.x.toFloat(), s.y.toFloat(),radiusST.x,radiusST.y, t.x.toFloat(), t.y.toFloat())
        pathBasket.cubicTo(t.x.toFloat(), t.y.toFloat(),radiusTU.x,radiusTU.y, u.x.toFloat(), u.y.toFloat())
        pathBasket.cubicTo(u.x.toFloat(), u.y.toFloat(),radiusUV.x,radiusUV.y, v.x.toFloat(), v.y.toFloat())
        pathBasket.cubicTo(v.x.toFloat(), v.y.toFloat(),radiusVW.x,radiusVW.y, w.x.toFloat(), w.y.toFloat())
        pathBasket.cubicTo(w.x.toFloat(), w.y.toFloat(),radiusWX.x,radiusWX.y, x.x.toFloat(), x.y.toFloat())
        pathBasket.cubicTo(x.x.toFloat(), x.y.toFloat(),radiusXY.x,radiusXY.y, y.x.toFloat(), y.y.toFloat())
        pathBasket.cubicTo(y.x.toFloat(), y.y.toFloat(),radiusYZ.x,radiusYZ.y, z.x.toFloat(), z.y.toFloat())
        pathBasket.lineTo(a1.x.toFloat(), a1.y.toFloat())
        pathBasket.cubicTo(a1.x.toFloat(), a1.y.toFloat(),radiusAB1.x,radiusAB1.y, b1.x.toFloat(), b1.y.toFloat())
        pathBasket.cubicTo(b1.x.toFloat(), b1.y.toFloat(),radiusBC1.x,radiusBC1.y, c1.x.toFloat(), c1.y.toFloat())
        pathBasket.cubicTo(c1.x.toFloat(), c1.y.toFloat(),radiusCD1.x,radiusCD1.y, d1.x.toFloat(), d1.y.toFloat())
        pathBasket.cubicTo(d1.x.toFloat(), d1.y.toFloat(),radiusDE1.x,radiusDE1.y, e1.x.toFloat(), e1.y.toFloat())
        pathBasket.cubicTo(e1.x.toFloat(), e1.y.toFloat(),radiusEA1.x,radiusEA1.y, a.x.toFloat(), a.y.toFloat())
        pathBasket.close()

        canvas.drawPath(pathBasket,paint)

    }


    override fun setAlpha(alpha: Int) {
        paint.alpha=alpha
    }

    override fun getOpacity(): Int = PixelFormat.OPAQUE

    override fun setColorFilter(colorFilter: ColorFilter?) {
        paint.colorFilter = colorFilter
    }


}