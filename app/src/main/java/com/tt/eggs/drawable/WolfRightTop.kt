package com.tt.eggs.drawable

import android.content.Context
import android.graphics.*
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.tt.eggs.R
import com.tt.eggs.classes.Functions

class WolfRightTop (private val context: Context, private val width: Double): Drawable() {
    private val paint = Paint()
    private val unit = width/100

    override fun draw(canvas: Canvas) {

        paint.style = Paint.Style.FILL_AND_STROKE
        paint.color = ContextCompat.getColor(context, R.color.black)
        paint.strokeWidth = (unit/2).toFloat()

        var a = Point((width-(width*0.5)).toInt(), (width*0.1).toInt())
        var b = Point((width-(width*0.48)).toInt(), (width*0.09).toInt())
        var radiusAB = Functions.curvedPath(a,b,unit*5,false)
        var c = Point((width-(width*0.52)).toInt(), (width*0.05).toInt())
        var d = Point((width-(width*0.68)).toInt(), (width*0.13).toInt())
        var e = Point((width-(width*0.68)).toInt(), (width*0.17).toInt())
        var f = Point((width-(width*0.73)).toInt(), (width*0.2).toInt())
        var g = Point((width-(width*0.81)).toInt(), (width*0.26).toInt())
        var radiusFG = Functions.curvedPath(f,g,unit*12,false)
        var h = Point((width-(width*0.77)).toInt(), (width*0.23).toInt())
        var radiusGH = Functions.curvedPath(g,h,unit,true)
        var i = Point((width-(width*0.79)).toInt(), (width*0.27).toInt())
        var j = Point((width-(width*0.79)).toInt(), (width*0.37).toInt())
        var radiusIJ = Functions.curvedPath(i,j,unit*3,false)
        var k = Point((width-(width*0.765)).toInt(), (width*0.29).toInt())
        var radiusJK = Functions.curvedPath(j,k,unit*2,true)
        var l = Point((width-(width*0.75)).toInt(), (width*0.38).toInt())
        var radiusKL = Functions.curvedPath(k,l,unit*1,false)
        var m = Point((width-(width*0.67)).toInt(), (width*0.38).toInt())
        var radiusLM = Functions.curvedPath(l,m,unit*2,true)
        var n = Point((width-(width*0.67)).toInt(), (width*0.31).toInt())
        var radiusMN = Functions.curvedPath(m,n,unit*3,true)
        var o = Point((width-(width*0.66)).toInt(), (width*0.275).toInt())
        var radiusNO = Functions.curvedPath(n,o,unit*2,true)
        var p = Point((width-(width*0.66)).toInt(), (width*0.2).toInt())
        var radiusOP = Functions.curvedPath(o,p,unit*3,true)
        var r = Point((width-(width*0.55)).toInt(), (width*0.14).toInt())
        var s = Point((width-(width*0.51)).toInt(), (width*0.16).toInt())
        var radiusRS = Functions.curvedPath(r,s,unit*2,true)
        var t = Point((width-(width*0.495)).toInt(), (width*0.16).toInt())
        var radiusST = Functions.curvedPath(s,t,unit*2,false)
        var u = Point((width-(width*0.54)).toInt(), (width*0.11).toInt())
        var radiusTU = Functions.curvedPath(t,u,unit*2,false)
        var v = Point((width-(width*0.54)).toInt(), (width*0.09).toInt())
        var radiusUV = Functions.curvedPath(u,v,unit*2,true)
        var radiusVA = Functions.curvedPath(v,a,unit,true)



        val path = Path()
        path.moveTo(a.x.toFloat(), a.y.toFloat())
        path.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        path.lineTo(c.x.toFloat(), c.y.toFloat())
        path.lineTo(d.x.toFloat(), d.y.toFloat())
        path.lineTo(e.x.toFloat(), e.y.toFloat())
        path.lineTo(f.x.toFloat(), f.y.toFloat())
        path.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        path.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        path.lineTo(i.x.toFloat(), i.y.toFloat())
        path.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        path.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        path.cubicTo(k.x.toFloat(), k.y.toFloat(),radiusKL.x,radiusKL.y, l.x.toFloat(), l.y.toFloat())
        path.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        path.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        path.cubicTo(n.x.toFloat(), n.y.toFloat(),radiusNO.x,radiusNO.y, o.x.toFloat(), o.y.toFloat())
        path.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())
        path.lineTo(r.x.toFloat(), r.y.toFloat())
        path.cubicTo(r.x.toFloat(), r.y.toFloat(),radiusRS.x,radiusRS.y, s.x.toFloat(), s.y.toFloat())
        path.cubicTo(s.x.toFloat(), s.y.toFloat(),radiusST.x,radiusST.y, t.x.toFloat(), t.y.toFloat())
        path.cubicTo(t.x.toFloat(), t.y.toFloat(),radiusTU.x,radiusTU.y, u.x.toFloat(), u.y.toFloat())
        path.cubicTo(u.x.toFloat(), u.y.toFloat(),radiusUV.x,radiusUV.y, v.x.toFloat(), v.y.toFloat())
        path.cubicTo(v.x.toFloat(), v.y.toFloat(),radiusVA.x,radiusVA.y, a.x.toFloat(), a.y.toFloat())
        path.close()

        canvas.drawPath(path,paint)

        paint.style = Paint.Style.FILL_AND_STROKE

        val path1 = Path()

        a = Point((width-(width*0.73)).toInt(), (width*0.375).toInt())
        b = Point((width-(width*0.73)).toInt(), (width*0.42).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,true)
        c = Point((width-(width*0.73)).toInt(), (width*0.44).toInt())
        var radiusBC = Functions.curvedPath(b,c,unit,false)
        d = Point((width-(width*0.65)).toInt(), (width*0.55).toInt())
        e = Point((width-(width*0.63)).toInt(), (width*0.63).toInt())
        f = Point((width-(width*0.6)).toInt(), (width*0.66).toInt())
        g = Point((width-(width*0.58)).toInt(), (width*0.67).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*2,true)
        h = Point((width-(width*0.49)).toInt(), (width*0.66).toInt())
        radiusGH = Functions.curvedPath(g,h,unit,true)
        i = Point((width-(width*0.47)).toInt(), (width*0.61).toInt())
        var radiusHI = Functions.curvedPath(h,i,unit*3,false)
        j = Point((width-(width*0.51)).toInt(), (width*0.55).toInt())
        k = Point((width-(width*0.54)).toInt(), (width*0.49).toInt())
        radiusJK = Functions.curvedPath(j,k,unit,false)
        l = Point((width-(width*0.56)).toInt(), (width*0.44).toInt())
        radiusKL = Functions.curvedPath(k,l,unit,true)
        m = Point((width-(width*0.6)).toInt(), (width*0.41).toInt())
        radiusLM = Functions.curvedPath(l,m,unit*2,false)
        n = Point((width-(width*0.605)).toInt(), (width*0.45).toInt())
        radiusMN = Functions.curvedPath(m,n,unit*2,false)
        o = Point((width-(width*0.58)).toInt(), (width*0.5).toInt())
        p = Point((width-(width*0.565)).toInt(), (width*0.535).toInt())
        radiusOP = Functions.curvedPath(o,p,unit*2,true)
        var q = Point((width-(width*0.63)).toInt(), (width*0.5).toInt())
        var radiusPQ = Functions.curvedPath(p,q,unit*3,true)
        r = Point((width-(width*0.68)).toInt(), (width*0.41).toInt())
        s = Point((width-(width*0.69)).toInt(), (width*0.39).toInt())
        radiusRS = Functions.curvedPath(r,s,unit,false)
        t = Point((width-(width*0.69)).toInt(), (width*0.37).toInt())
        radiusST = Functions.curvedPath(s,t,unit,true)

        path1.moveTo(a.x.toFloat(), a.y.toFloat())
        path1.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        path1.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        path1.lineTo(d.x.toFloat(), d.y.toFloat())
        path1.lineTo(e.x.toFloat(), e.y.toFloat())
        path1.lineTo(f.x.toFloat(), f.y.toFloat())
        path1.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        path1.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        path1.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        path1.lineTo(j.x.toFloat(), j.y.toFloat())
        path1.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        path1.cubicTo(k.x.toFloat(), k.y.toFloat(),radiusKL.x,radiusKL.y, l.x.toFloat(), l.y.toFloat())
        path1.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        path1.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        path1.lineTo(o.x.toFloat(), o.y.toFloat())
        path1.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())
        path1.cubicTo(p.x.toFloat(), p.y.toFloat(),radiusPQ.x,radiusPQ.y, q.x.toFloat(), q.y.toFloat())
        path1.lineTo(r.x.toFloat(), r.y.toFloat())
        path1.cubicTo(r.x.toFloat(), r.y.toFloat(),radiusRS.x,radiusRS.y, s.x.toFloat(), s.y.toFloat())
        path1.cubicTo(s.x.toFloat(), s.y.toFloat(),radiusST.x,radiusST.y, t.x.toFloat(), t.y.toFloat())
        path1.close()

        canvas.drawPath(path1,paint)


        paint.style = Paint.Style.STROKE
        paint.strokeWidth = (unit*1.5).toFloat()
        val pathLegs = Path()

        a= Point((width-(width*0.62)).toInt(), (width*0.62).toInt())
        b= Point((width-(width*0.78)).toInt(), (width*0.72).toInt())
        c = Point((width-(width*0.79)).toInt(), (width*0.76).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*2,false)
        d = Point((width-(width*0.75)).toInt(), (width*0.855).toInt())
        e = Point((width-(width*0.68)).toInt(), (width*0.9).toInt())
        f = Point((width-(width*0.84)).toInt(), (width*0.84).toInt())
        var radiusEF = Functions.curvedPath(e,f,unit*4,false)
        g = Point((width-(width*0.85)).toInt(), (width*0.87).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*4,false)
        h = Point((width-(width*0.68)).toInt(), (width*0.94).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*4,false)
        var radiusHE = Functions.curvedPath(h,e,unit*3,false)
        i = Point((width-(width*0.73)).toInt(), (width*0.78).toInt())
        j = Point((width-(width*0.71)).toInt(), (width*0.75).toInt())
        radiusIJ = Functions.curvedPath(i,j,unit*3,true)
        k = Point((width-(width*0.54)).toInt(), (width*0.73).toInt())
        l = Point((width-(width*0.435)).toInt(), (width*0.77).toInt())
        m = Point((width-(width*0.55)).toInt(), (width*0.86).toInt())
        n = Point((width-(width*0.53)).toInt(), (width*0.95).toInt())
        radiusMN = Functions.curvedPath(m,n,unit*9,false)
        o = Point((width-(width*0.36)).toInt(), (width*0.93).toInt())
        radiusNO = Functions.curvedPath(n,o,unit*4,false)
        p = Point((width-(width*0.34)).toInt(), (width*0.87).toInt())
        radiusOP = Functions.curvedPath(o,p,unit*4,false)
        q = Point((width-(width*0.48)).toInt(), (width*0.885).toInt())
        radiusPQ = Functions.curvedPath(p,q,unit*3,false)
        r = Point((width-(width*0.49)).toInt(), (width*0.86).toInt())
        var radiusQR = Functions.curvedPath(q,r,unit*6,true)
        s = Point((width-(width*0.36)).toInt(), (width*0.785).toInt())
        t = Point((width-(width*0.35)).toInt(), (width*0.74).toInt())
        radiusST = Functions.curvedPath(s,t,unit*4,false)
        u = Point((width-(width*0.49)).toInt(), (width*0.64).toInt())
        radiusTU = Functions.curvedPath(t,u,unit,false)

        pathLegs.moveTo(a.x.toFloat(), a.y.toFloat())
        pathLegs.lineTo(b.x.toFloat(), b.y.toFloat())
        pathLegs.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathLegs.lineTo(d.x.toFloat(), d.y.toFloat())
        pathLegs.moveTo(e.x.toFloat(), e.y.toFloat())
        pathLegs.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathLegs.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        pathLegs.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        pathLegs.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHE.x,radiusHE.y, e.x.toFloat(), e.y.toFloat())
        pathLegs.lineTo(i.x.toFloat(), i.y.toFloat())
        pathLegs.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        pathLegs.lineTo(k.x.toFloat(), k.y.toFloat())
        pathLegs.lineTo(l.x.toFloat(), l.y.toFloat())
        pathLegs.lineTo(m.x.toFloat(), m.y.toFloat())
        pathLegs.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        pathLegs.cubicTo(n.x.toFloat(), n.y.toFloat(),radiusNO.x,radiusNO.y, o.x.toFloat(), o.y.toFloat())
        pathLegs.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())
        pathLegs.cubicTo(p.x.toFloat(), p.y.toFloat(),radiusPQ.x,radiusPQ.y, q.x.toFloat(), q.y.toFloat())
        pathLegs.cubicTo(q.x.toFloat(), q.y.toFloat(),radiusQR.x,radiusQR.y, r.x.toFloat(), r.y.toFloat())
        pathLegs.lineTo(s.x.toFloat(), s.y.toFloat())
        pathLegs.cubicTo(s.x.toFloat(), s.y.toFloat(),radiusST.x,radiusST.y, t.x.toFloat(), t.y.toFloat())
        pathLegs.cubicTo(t.x.toFloat(), t.y.toFloat(),radiusTU.x,radiusTU.y, u.x.toFloat(), u.y.toFloat())

        canvas.drawPath(pathLegs,paint)


        val pathPants = Path()

        a = Point((width-(width*0.45)).toInt(), (width*0.76).toInt())
        b = Point((width-(width*0.37)).toInt(), (width*0.71).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,true)
        c = Point((width-(width*0.5)).toInt(), (width*0.6).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*2,true)
        d = Point((width-(width*0.38)).toInt(), (width*0.87).toInt())
        e = Point((width-(width*0.41)).toInt(), (width*0.92).toInt())
        var radiusDE = Functions.curvedPath(d,e,unit*4,true)
        f = Point((width-(width*0.58)).toInt(), (width*0.9).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*3,true)
        g = Point((width-(width*0.68)).toInt(), (width*0.94).toInt())
        h = Point((width-(width*0.855)).toInt(), (width*0.86).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*3,false)
        i = Point((width-(width*0.68)).toInt(), (width*0.745).toInt())
        j = Point((width-(width*0.73)).toInt(), (width*0.67).toInt())
        radiusIJ = Functions.curvedPath(i,j,unit,false)
        k = Point((width-(width*0.6)).toInt(), (width*0.6).toInt())
        radiusJK = Functions.curvedPath(j,k,unit,false)
        l = Point((width-(width*0.65)).toInt(), (width*0.63).toInt())
        m = Point((width-(width*0.73)).toInt(), (width*0.58).toInt())
        radiusLM = Functions.curvedPath(l,m,unit,false)
        n = Point((width-(width*0.76)).toInt(), (width*0.6).toInt())
        radiusMN = Functions.curvedPath(m,n,unit*3,false)
        o = Point((width-(width*0.69)).toInt(), (width*0.65).toInt())
        radiusNO = Functions.curvedPath(n,o,unit*2,false)

        pathPants.moveTo(a.x.toFloat(), a.y.toFloat())
        pathPants.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathPants.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathPants.moveTo(d.x.toFloat(), d.y.toFloat())
        pathPants.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        pathPants.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathPants.moveTo(g.x.toFloat(), g.y.toFloat())
        pathPants.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        pathPants.moveTo(i.x.toFloat(), i.y.toFloat())
        pathPants.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        pathPants.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        pathPants.moveTo(l.x.toFloat(), l.y.toFloat())
        pathPants.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        pathPants.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())
        pathPants.cubicTo(n.x.toFloat(), n.y.toFloat(),radiusNO.x,radiusNO.y, o.x.toFloat(), o.y.toFloat())

        canvas.drawPath(pathPants,paint)


        paint.strokeWidth = (unit*1.5).toFloat()
        a = Point((width-(width*0.68)).toInt(), (width*0.17).toInt())
        b = Point((width-(width*0.77)).toInt(), (width*0.05).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*6,false)
        c = Point((width-(width*0.73)).toInt(), (width*0.2).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*7,false)
        d = Point((width-(width*0.70)).toInt(), (width*0.18).toInt())
        e = Point((width-(width*0.74)).toInt(), (width*0.13).toInt())
        radiusDE = Functions.curvedPath(d,e,unit*2,false)
        f = Point((width-(width*0.71)).toInt(), (width*0.19).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*2,false)
        g = Point((width-(width*0.56)).toInt(), (width*0.08).toInt())
        h = Point((width-(width*0.64)).toInt(), (width*0.08).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*5,false)
        i = Point((width-(width*0.7)).toInt(), (width*0.09).toInt())
        j = Point((width-(width*0.68)).toInt(), (width*0.12).toInt())
        k = Point((width-(width*0.62)).toInt(), (width*0.105).toInt())
        l = Point((width-(width*0.64)).toInt(), (width*0.08).toInt())
        m = Point((width-(width*0.63)).toInt(), (width*0.08).toInt())
        n = Point((width-(width*0.61)).toInt(), (width*0.105).toInt())
        radiusHI = Functions.curvedPath(h,i,unit*3,false)
        o = Point((width-(width*0.67)).toInt(), (width*0.07).toInt())
        p = Point((width-(width*0.7)).toInt(), (width*0.08).toInt())
        radiusOP = Functions.curvedPath(o,p,unit*8,false)



        val pathEar = Path()
        pathEar.moveTo(a.x.toFloat(), a.y.toFloat())
        pathEar.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathEar.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathEar.moveTo(d.x.toFloat(), d.y.toFloat())
        pathEar.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        pathEar.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathEar.moveTo(g.x.toFloat(), g.y.toFloat())
        pathEar.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        pathEar.lineTo(i.x.toFloat(), i.y.toFloat())
        pathEar.lineTo(j.x.toFloat(), j.y.toFloat())
        pathEar.lineTo(k.x.toFloat(), k.y.toFloat())
        pathEar.lineTo(l.x.toFloat(), l.y.toFloat())
        pathEar.lineTo(m.x.toFloat(), m.y.toFloat())
        pathEar.lineTo(n.x.toFloat(), n.y.toFloat())
        pathEar.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        pathEar.moveTo(o.x.toFloat(), o.y.toFloat())
        pathEar.cubicTo(o.x.toFloat(), o.y.toFloat(),radiusOP.x,radiusOP.y, p.x.toFloat(), p.y.toFloat())

        canvas.drawPath(pathEar,paint)

        paint.style = Paint.Style.FILL_AND_STROKE
        paint.strokeWidth = (unit*0.5).toFloat()
        a = Point((width-(width*0.55)).toInt(), (width*0.14).toInt())
        b = Point((width-(width*0.525)).toInt(), (width*0.21).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,true)
        c = Point((width-(width*0.54)).toInt(), (width*0.21).toInt())
        d = Point((width-(width*0.57)).toInt(), (width*0.18).toInt())
        var radiusCD = Functions.curvedPath(c,d,unit*4,false)
        e = Point((width-(width*0.61)).toInt(), (width*0.2).toInt())
        radiusDE = Functions.curvedPath(d,e,unit*5,false)
        f = Point((width-(width*0.63)).toInt(), (width*0.21).toInt())
        g = Point((width-(width*0.68)).toInt(), (width*0.17).toInt())

        val path2 = Path()
        path2.moveTo(a.x.toFloat(), a.y.toFloat())
        path2.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        path2.lineTo(c.x.toFloat(), c.y.toFloat())
        path2.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCD.x,radiusCD.y, d.x.toFloat(), d.y.toFloat())
        path2.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        path2.lineTo(f.x.toFloat(), f.y.toFloat())
        path2.lineTo(g.x.toFloat(), g.y.toFloat())
        path2.close()

        canvas.drawPath(path2,paint)


        paint.style = Paint.Style.STROKE
        paint.strokeWidth = (unit*1.5).toFloat()

        a = Point((width-(width*0.58)).toInt(), (width*0.22).toInt())
        b = Point((width-(width*0.63)).toInt(), (width*0.21).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*4,false)
        c = Point((width-(width*0.585)).toInt(), (width*0.24).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*10,false)
        d = Point((width-(width*0.525)).toInt(), (width*0.23).toInt())
        radiusCD = Functions.curvedPath(c,d,unit*6,true)
        e = Point((width-(width*0.565)).toInt(), (width*0.28).toInt())
        var radiusEA = Functions.curvedPath(e,a,unit*3,true)
        f = Point((width-(width*0.53)).toInt(), (width*0.28).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*4,true)
        g = Point((width-(width*0.41)).toInt(), (width*0.26).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*8,true)
        h = Point((width-(width*0.42)).toInt(), (width*0.31).toInt())
        i = Point((width-(width*0.43)).toInt(), (width*0.37).toInt())
        radiusHI = Functions.curvedPath(h,i,unit,true)
        j = Point((width-(width*0.47)).toInt(), (width*0.39).toInt())
        radiusIJ = Functions.curvedPath(i,j,unit,false)
        k = Point((width-(width*0.51)).toInt(), (width*0.4).toInt())
        radiusJK = Functions.curvedPath(j,k,unit*2,true)
        l = Point((width-(width*0.58)).toInt(), (width*0.36).toInt())
        radiusKL = Functions.curvedPath(k,l,unit,true)
        m = Point((width-(width*0.64)).toInt(), (width*0.35).toInt())
        radiusLM = Functions.curvedPath(l,m,unit*2,true)
        n = Point((width-(width*0.6)).toInt(), (width*0.44).toInt())
        radiusMN = Functions.curvedPath(m,n,unit*2,true)

        val pathFace = Path()
        pathFace.moveTo(a.x.toFloat(), a.y.toFloat())
        pathFace.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathFace.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        pathFace.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCD.x,radiusCD.y, d.x.toFloat(), d.y.toFloat())
        pathFace.lineTo(e.x.toFloat(), e.y.toFloat())
        pathFace.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEA.x,radiusEA.y, a.x.toFloat(), a.y.toFloat())
        pathFace.moveTo(e.x.toFloat(), e.y.toFloat())
        pathFace.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        pathFace.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        pathFace.lineTo(h.x.toFloat(), h.y.toFloat())
        pathFace.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHI.x,radiusHI.y, i.x.toFloat(), i.y.toFloat())
        pathFace.cubicTo(i.x.toFloat(), i.y.toFloat(),radiusIJ.x,radiusIJ.y, j.x.toFloat(), j.y.toFloat())
        pathFace.cubicTo(j.x.toFloat(), j.y.toFloat(),radiusJK.x,radiusJK.y, k.x.toFloat(), k.y.toFloat())
        pathFace.cubicTo(k.x.toFloat(), k.y.toFloat(),radiusKL.x,radiusKL.y, l.x.toFloat(), l.y.toFloat())
        pathFace.cubicTo(l.x.toFloat(), l.y.toFloat(),radiusLM.x,radiusLM.y, m.x.toFloat(), m.y.toFloat())
        pathFace.cubicTo(m.x.toFloat(), m.y.toFloat(),radiusMN.x,radiusMN.y, n.x.toFloat(), n.y.toFloat())

        canvas.drawPath(pathFace,paint)


        paint.style = Paint.Style.FILL_AND_STROKE
        paint.strokeWidth = (unit/2).toFloat()

        a = Point((width-(width*0.42)).toInt(), (width*0.31).toInt())
        b = Point((width-(width*0.47)).toInt(), (width*0.31).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*2,false)
        c = Point((width-(width*0.47)).toInt(), (width*0.35).toInt())
        radiusBC = Functions.curvedPath(b,c,unit*3,true)
        var radiusCB = Functions.curvedPath(c,b,unit*3,true)
        d = Point((width-(width*0.59)).toInt(), (width*0.3).toInt())
        var radiusBD = Functions.curvedPath(b,d,unit*2,true)
        e = Point((width-(width*0.61)).toInt(), (width*0.32).toInt())
        radiusDE = Functions.curvedPath(d,e,unit*2,false)
        f = Point((width-(width*0.58)).toInt(), (width*0.34).toInt())
        radiusEF = Functions.curvedPath(e,f,unit*2,false)
        g = Point((width-(width*0.48)).toInt(), (width*0.37).toInt())
        radiusFG = Functions.curvedPath(f,g,unit*2,true)
        h = Point((width-(width*0.43)).toInt(), (width*0.36).toInt())
        radiusGH = Functions.curvedPath(g,h,unit*3,true)
        var radiusHA = Functions.curvedPath(h,a,unit*4,true)

        val path3 = Path()
        path3.moveTo(a.x.toFloat(), a.y.toFloat())
        path3.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        path3.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBC.x,radiusBC.y, c.x.toFloat(), c.y.toFloat())
        path3.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCB.x,radiusCB.y, b.x.toFloat(), b.y.toFloat())
        path3.cubicTo(b.x.toFloat(), b.y.toFloat(),radiusBD.x,radiusBD.y, d.x.toFloat(), d.y.toFloat())
        path3.cubicTo(d.x.toFloat(), d.y.toFloat(),radiusDE.x,radiusDE.y, e.x.toFloat(), e.y.toFloat())
        path3.cubicTo(e.x.toFloat(), e.y.toFloat(),radiusEF.x,radiusEF.y, f.x.toFloat(), f.y.toFloat())
        path3.cubicTo(f.x.toFloat(), f.y.toFloat(),radiusFG.x,radiusFG.y, g.x.toFloat(), g.y.toFloat())
        path3.cubicTo(g.x.toFloat(), g.y.toFloat(),radiusGH.x,radiusGH.y, h.x.toFloat(), h.y.toFloat())
        path3.cubicTo(h.x.toFloat(), h.y.toFloat(),radiusHA.x,radiusHA.y, a.x.toFloat(), a.y.toFloat())
        path3.close()

        canvas.drawPath(path3,paint)


        a = Point((width-(width*0.43)).toInt(), (width*0.18).toInt())
        b = Point((width-(width*0.445)).toInt(), (width*0.27).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*4,false)
        c = Point((width-(width*0.41)).toInt(), (width*0.24).toInt())
        var radiusCA = Functions.curvedPath(c,a,unit*4,false)

        val pathNose = Path()
        pathNose.moveTo(a.x.toFloat(), a.y.toFloat())
        pathNose.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathNose.lineTo(c.x.toFloat(), c.y.toFloat())
        pathNose.cubicTo(c.x.toFloat(), c.y.toFloat(),radiusCA.x,radiusCA.y, a.x.toFloat(), a.y.toFloat())
        path3.close()

        canvas.drawPath(pathNose,paint)

        paint.style = Paint.Style.FILL_AND_STROKE
//
        paint.strokeWidth = (unit/2).toFloat()

        a = Point((width-(width*0.53)).toInt(), (width*0.24).toInt())
        b = Point((width-(width*0.56)).toInt(), (width*0.27).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*4,false)


        val pathEye = Path()
        pathEye.moveTo(a.x.toFloat(), a.y.toFloat())
        pathEye.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathEye.close()

        canvas.drawPath(pathEye,paint)

        a = Point((width-(width*0.59)).toInt(), (width*0.23).toInt())
        b = Point((width-(width*0.62)).toInt(), (width*0.26).toInt())
        radiusAB = Functions.curvedPath(a,b,unit*4,false)


        val pathEye1 = Path()
        pathEye1.moveTo(a.x.toFloat(), a.y.toFloat())
        pathEye1.cubicTo(a.x.toFloat(), a.y.toFloat(),radiusAB.x,radiusAB.y, b.x.toFloat(), b.y.toFloat())
        pathEye1.close()

        canvas.drawPath(pathEye1,paint)


    }


    override fun setAlpha(alpha: Int) {
        paint.alpha=alpha
    }

    override fun getOpacity(): Int = PixelFormat.OPAQUE

    override fun setColorFilter(colorFilter: ColorFilter?) {
        paint.colorFilter = colorFilter
    }


}